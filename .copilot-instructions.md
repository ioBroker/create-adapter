# ioBroker Create-Adapter - Copilot Instructions

## Project Overview

This is a CLI tool for generating customized ioBroker adapter projects. It's a scaffolding utility that uses a template-based system to create complete adapter directories with all necessary files based on user preferences.

**ioBroker Context**: ioBroker is a home automation platform, and adapters are plugins that connect various devices, services, and protocols to the platform. This tool helps developers quickly scaffold new adapters with modern development practices and standardized structure.

## Key Concepts

### Template System
- **Template Functions**: Located in `/templates/`, these are TypeScript files that export a `TemplateFunction`
- **Answers Object**: User input flows through the system as an `Answers` object containing all configuration choices
- **File Generation**: Templates generate file content based on user answers and are written to target directories

### Core Architecture
```typescript
// Template function signature
type TemplateFunction = (answers: Answers) => string | Promise<string> | undefined;

// Templates can have custom properties
templateFunction.customPath = "custom/file/path";
templateFunction.noReformat = true; // Skip automatic formatting
```

### User Interaction Flow
1. CLI prompts collect user preferences into `Answers` object using `enquirer`
2. Validation ensures required fields are provided and constraints are met
3. Templates process answers to generate file content conditionally
4. Files are written to target directory with proper formatting via Prettier
5. Dependencies are optionally installed and initial build performed
6. Git repository is optionally initialized with initial commit

### Error Handling Patterns
- Use descriptive error messages for user-facing CLI errors
- Validate user input early in the process before template generation
- Handle network failures gracefully (package version fetching)
- Provide fallback behavior when optional operations fail

## Development Patterns

### Template Development
- Template files end in `.ts` and export a function as the default export
- Use conditional logic to return `undefined` when template shouldn't be generated
- Access user answers through the `answers` parameter
- Use template literals for multi-line content

```typescript
export = (answers => {
    if (!answers.someFeature) return; // Skip if feature not selected
    
    const template = `
// Generated content based on ${answers.someProperty}
    `;
    return template.trim();
}) as TemplateFunction;
```

### Answer Object Structure
Key properties commonly used in templates:
- `answers.adapterName` - The adapter name
- `answers.authorName` - Author's full name  
- `answers.authorGithub` - GitHub username
- `answers.features` - Array of selected features
- `answers.language` - "TypeScript" or "JavaScript"
- `answers.adminUi` - Admin UI type ("html", "react", "json", "none")
- `answers.indentation` - "Tab" or "Space (4)"
- `answers.quotes` - "double" or "single"
- `answers.es6class` - Whether to use ES6 classes

### Testing Patterns
- **Baseline Tests**: Generate complete adapter directories and compare with stored baselines
- **Unit Tests**: Test individual functions and utilities
- **Template Tests**: Verify templates generate expected content for different answer combinations

### File Path Conventions
- Source files: `/src/`
- Templates: `/templates/`
- Build output: `/build/`
- Test baselines: `/test/baselines/`

### Code Style
- TypeScript throughout the codebase
- ESLint + Prettier for formatting
- Prefer explicit types over `any`
- Use `async/await` over Promises
- Follow existing naming conventions

## Common Operations

### Adding a New Template
1. Create `.ts` file in appropriate `/templates/` subdirectory
2. Export a `TemplateFunction` that processes answers
3. Set `customPath` property if output path differs from template path
4. Add conditional logic to return `undefined` when not needed
5. Test with relevant answer combinations

### Modifying Existing Templates
1. Understand what answers control the template
2. Maintain backward compatibility with existing answer structures
3. Test changes against baseline test suite
4. Update baseline files if behavior change is intentional

### Testing Changes
```bash
npm test                    # Run all tests
npm run test:ts            # Unit tests only
npm run test:baselines     # Baseline generation tests
npm run build              # Rebuild templates
```

### Debugging Template Generation
- Use `console.log` in templates to debug answer processing
- Check baseline test outputs in `/test/baselines/`
- Run single test cases to isolate issues

## File Generation Process

1. **Preprocessing**: Link templates, cache licenses
2. **Question Flow**: Collect user answers via CLI prompts
3. **Template Processing**: Each template function receives answers object
4. **File Writing**: Generated content written to target directory
5. **Post-processing**: Install dependencies, run build steps if requested

## Migration and Compatibility

- The tool supports migrating existing adapters via `--migrate` flag
- Answer format is preserved in `.create-adapter.json` for replay functionality
- Backward compatibility is maintained for existing answer structures

## Important Notes

- Templates are compiled from TypeScript to JavaScript during build
- Raw files (`.raw.*` extensions) are copied without processing
- Formatting is automatically applied unless `noReformat: true` is set
- Git initialization is optional and controlled by user answers
- All file paths should use forward slashes for cross-platform compatibility

## Getting Started with Development

1. Install dependencies: `npm install`
2. Build project: `npm run build`
3. Run tests: `npm test`
4. Watch for changes: `npm run watch`
5. Test CLI locally: `npm link` then `create-adapter`

This tool is actively maintained and used by the ioBroker community to create hundreds of adapters. Changes should be thoroughly tested and maintain backward compatibility.

## Pull Request Requirements

When making a PR to this repository, ensure the following points are addressed:

- **Meaningful PR description**: Provide a clear description to this PR or mention which issues this fixes.
- **Project builds**: Ensure the project builds successfully with `npm run build`
- **Tests included**: Add tests for your change. This includes negative tests (i.e. inputs that need to fail) as well as baseline tests (i.e. how should the directory structure look like?).
- **Test suite passes**: Run the test suite with `npm test` and ensure all tests pass
- **Baseline changes**: If there are baseline changes, review them and make a separate commit for them with the comment "accept baselines" if they are desired changes
- **Template creation updates**: If you added a required option, also add it to the template creation (`.github/create_templates.ts`)
- **Migration documentation**: Add a detailed migration description to `docs/updates` explaining what the user needs to do when manually updating an existing project
- **CHANGELOG.md updated**: Add your changes to CHANGELOG.md (referencing the migration description and this PR or the issue you fixed)

These requirements help maintain code quality, ensure proper testing coverage, and provide clear documentation for users upgrading existing projects.